/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_UFS_GENERATED_TRACERS_H
#define TRACE_HW_UFS_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_UFS_IRQ_RAISE_EVENT;
extern TraceEvent _TRACE_UFS_IRQ_LOWER_EVENT;
extern TraceEvent _TRACE_UFS_MMIO_READ_EVENT;
extern TraceEvent _TRACE_UFS_MMIO_WRITE_EVENT;
extern TraceEvent _TRACE_UFS_PROCESS_DB_EVENT;
extern TraceEvent _TRACE_UFS_PROCESS_REQ_EVENT;
extern TraceEvent _TRACE_UFS_COMPLETE_REQ_EVENT;
extern TraceEvent _TRACE_UFS_SENDBACK_REQ_EVENT;
extern TraceEvent _TRACE_UFS_EXEC_NOP_CMD_EVENT;
extern TraceEvent _TRACE_UFS_EXEC_SCSI_CMD_EVENT;
extern TraceEvent _TRACE_UFS_EXEC_QUERY_CMD_EVENT;
extern TraceEvent _TRACE_UFS_PROCESS_UICCMD_EVENT;
extern TraceEvent _TRACE_UFS_ERR_DMA_READ_UTRD_EVENT;
extern TraceEvent _TRACE_UFS_ERR_DMA_READ_REQ_UPIU_EVENT;
extern TraceEvent _TRACE_UFS_ERR_DMA_READ_PRDT_EVENT;
extern TraceEvent _TRACE_UFS_ERR_DMA_WRITE_UTRD_EVENT;
extern TraceEvent _TRACE_UFS_ERR_DMA_WRITE_RSP_UPIU_EVENT;
extern TraceEvent _TRACE_UFS_ERR_UTRL_SLOT_ERROR_EVENT;
extern TraceEvent _TRACE_UFS_ERR_UTRL_SLOT_BUSY_EVENT;
extern TraceEvent _TRACE_UFS_ERR_UNSUPPORT_REGISTER_OFFSET_EVENT;
extern TraceEvent _TRACE_UFS_ERR_INVALID_REGISTER_OFFSET_EVENT;
extern TraceEvent _TRACE_UFS_ERR_SCSI_CMD_INVALID_LUN_EVENT;
extern TraceEvent _TRACE_UFS_ERR_QUERY_FLAG_NOT_READABLE_EVENT;
extern TraceEvent _TRACE_UFS_ERR_QUERY_FLAG_NOT_WRITABLE_EVENT;
extern TraceEvent _TRACE_UFS_ERR_QUERY_ATTR_NOT_READABLE_EVENT;
extern TraceEvent _TRACE_UFS_ERR_QUERY_ATTR_NOT_WRITABLE_EVENT;
extern TraceEvent _TRACE_UFS_ERR_QUERY_INVALID_OPCODE_EVENT;
extern TraceEvent _TRACE_UFS_ERR_QUERY_INVALID_IDN_EVENT;
extern TraceEvent _TRACE_UFS_ERR_QUERY_INVALID_INDEX_EVENT;
extern TraceEvent _TRACE_UFS_ERR_INVALID_TRANS_CODE_EVENT;
extern uint16_t _TRACE_UFS_IRQ_RAISE_DSTATE;
extern uint16_t _TRACE_UFS_IRQ_LOWER_DSTATE;
extern uint16_t _TRACE_UFS_MMIO_READ_DSTATE;
extern uint16_t _TRACE_UFS_MMIO_WRITE_DSTATE;
extern uint16_t _TRACE_UFS_PROCESS_DB_DSTATE;
extern uint16_t _TRACE_UFS_PROCESS_REQ_DSTATE;
extern uint16_t _TRACE_UFS_COMPLETE_REQ_DSTATE;
extern uint16_t _TRACE_UFS_SENDBACK_REQ_DSTATE;
extern uint16_t _TRACE_UFS_EXEC_NOP_CMD_DSTATE;
extern uint16_t _TRACE_UFS_EXEC_SCSI_CMD_DSTATE;
extern uint16_t _TRACE_UFS_EXEC_QUERY_CMD_DSTATE;
extern uint16_t _TRACE_UFS_PROCESS_UICCMD_DSTATE;
extern uint16_t _TRACE_UFS_ERR_DMA_READ_UTRD_DSTATE;
extern uint16_t _TRACE_UFS_ERR_DMA_READ_REQ_UPIU_DSTATE;
extern uint16_t _TRACE_UFS_ERR_DMA_READ_PRDT_DSTATE;
extern uint16_t _TRACE_UFS_ERR_DMA_WRITE_UTRD_DSTATE;
extern uint16_t _TRACE_UFS_ERR_DMA_WRITE_RSP_UPIU_DSTATE;
extern uint16_t _TRACE_UFS_ERR_UTRL_SLOT_ERROR_DSTATE;
extern uint16_t _TRACE_UFS_ERR_UTRL_SLOT_BUSY_DSTATE;
extern uint16_t _TRACE_UFS_ERR_UNSUPPORT_REGISTER_OFFSET_DSTATE;
extern uint16_t _TRACE_UFS_ERR_INVALID_REGISTER_OFFSET_DSTATE;
extern uint16_t _TRACE_UFS_ERR_SCSI_CMD_INVALID_LUN_DSTATE;
extern uint16_t _TRACE_UFS_ERR_QUERY_FLAG_NOT_READABLE_DSTATE;
extern uint16_t _TRACE_UFS_ERR_QUERY_FLAG_NOT_WRITABLE_DSTATE;
extern uint16_t _TRACE_UFS_ERR_QUERY_ATTR_NOT_READABLE_DSTATE;
extern uint16_t _TRACE_UFS_ERR_QUERY_ATTR_NOT_WRITABLE_DSTATE;
extern uint16_t _TRACE_UFS_ERR_QUERY_INVALID_OPCODE_DSTATE;
extern uint16_t _TRACE_UFS_ERR_QUERY_INVALID_IDN_DSTATE;
extern uint16_t _TRACE_UFS_ERR_QUERY_INVALID_INDEX_DSTATE;
extern uint16_t _TRACE_UFS_ERR_INVALID_TRANS_CODE_DSTATE;
#define TRACE_UFS_IRQ_RAISE_ENABLED 1
#define TRACE_UFS_IRQ_LOWER_ENABLED 1
#define TRACE_UFS_MMIO_READ_ENABLED 1
#define TRACE_UFS_MMIO_WRITE_ENABLED 1
#define TRACE_UFS_PROCESS_DB_ENABLED 1
#define TRACE_UFS_PROCESS_REQ_ENABLED 1
#define TRACE_UFS_COMPLETE_REQ_ENABLED 1
#define TRACE_UFS_SENDBACK_REQ_ENABLED 1
#define TRACE_UFS_EXEC_NOP_CMD_ENABLED 1
#define TRACE_UFS_EXEC_SCSI_CMD_ENABLED 1
#define TRACE_UFS_EXEC_QUERY_CMD_ENABLED 1
#define TRACE_UFS_PROCESS_UICCMD_ENABLED 1
#define TRACE_UFS_ERR_DMA_READ_UTRD_ENABLED 1
#define TRACE_UFS_ERR_DMA_READ_REQ_UPIU_ENABLED 1
#define TRACE_UFS_ERR_DMA_READ_PRDT_ENABLED 1
#define TRACE_UFS_ERR_DMA_WRITE_UTRD_ENABLED 1
#define TRACE_UFS_ERR_DMA_WRITE_RSP_UPIU_ENABLED 1
#define TRACE_UFS_ERR_UTRL_SLOT_ERROR_ENABLED 1
#define TRACE_UFS_ERR_UTRL_SLOT_BUSY_ENABLED 1
#define TRACE_UFS_ERR_UNSUPPORT_REGISTER_OFFSET_ENABLED 1
#define TRACE_UFS_ERR_INVALID_REGISTER_OFFSET_ENABLED 1
#define TRACE_UFS_ERR_SCSI_CMD_INVALID_LUN_ENABLED 1
#define TRACE_UFS_ERR_QUERY_FLAG_NOT_READABLE_ENABLED 1
#define TRACE_UFS_ERR_QUERY_FLAG_NOT_WRITABLE_ENABLED 1
#define TRACE_UFS_ERR_QUERY_ATTR_NOT_READABLE_ENABLED 1
#define TRACE_UFS_ERR_QUERY_ATTR_NOT_WRITABLE_ENABLED 1
#define TRACE_UFS_ERR_QUERY_INVALID_OPCODE_ENABLED 1
#define TRACE_UFS_ERR_QUERY_INVALID_IDN_ENABLED 1
#define TRACE_UFS_ERR_QUERY_INVALID_INDEX_ENABLED 1
#define TRACE_UFS_ERR_INVALID_TRANS_CODE_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_UFS_IRQ_RAISE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_IRQ_RAISE) || \
    false)

static inline void _nocheck__trace_ufs_irq_raise(void)
{
    if (trace_event_get_state(TRACE_UFS_IRQ_RAISE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 2 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_irq_raise " "INTx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 118 "trace/trace-hw_ufs.h"
        } else {
#line 2 "../hw/ufs/trace-events"
            qemu_log("ufs_irq_raise " "INTx" "\n");
#line 122 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_irq_raise(void)
{
    if (true) {
        _nocheck__trace_ufs_irq_raise();
    }
}

#define TRACE_UFS_IRQ_LOWER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_IRQ_LOWER) || \
    false)

static inline void _nocheck__trace_ufs_irq_lower(void)
{
    if (trace_event_get_state(TRACE_UFS_IRQ_LOWER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 3 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_irq_lower " "INTx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 149 "trace/trace-hw_ufs.h"
        } else {
#line 3 "../hw/ufs/trace-events"
            qemu_log("ufs_irq_lower " "INTx" "\n");
#line 153 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_irq_lower(void)
{
    if (true) {
        _nocheck__trace_ufs_irq_lower();
    }
}

#define TRACE_UFS_MMIO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_MMIO_READ) || \
    false)

static inline void _nocheck__trace_ufs_mmio_read(uint64_t addr, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_UFS_MMIO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_mmio_read " "addr 0x%"PRIx64" data 0x%"PRIx64" size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data, size);
#line 180 "trace/trace-hw_ufs.h"
        } else {
#line 4 "../hw/ufs/trace-events"
            qemu_log("ufs_mmio_read " "addr 0x%"PRIx64" data 0x%"PRIx64" size %d" "\n", addr, data, size);
#line 184 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_mmio_read(uint64_t addr, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_ufs_mmio_read(addr, data, size);
    }
}

#define TRACE_UFS_MMIO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_MMIO_WRITE) || \
    false)

static inline void _nocheck__trace_ufs_mmio_write(uint64_t addr, uint64_t data, unsigned size)
{
    if (trace_event_get_state(TRACE_UFS_MMIO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_mmio_write " "addr 0x%"PRIx64" data 0x%"PRIx64" size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, data, size);
#line 211 "trace/trace-hw_ufs.h"
        } else {
#line 5 "../hw/ufs/trace-events"
            qemu_log("ufs_mmio_write " "addr 0x%"PRIx64" data 0x%"PRIx64" size %d" "\n", addr, data, size);
#line 215 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_mmio_write(uint64_t addr, uint64_t data, unsigned size)
{
    if (true) {
        _nocheck__trace_ufs_mmio_write(addr, data, size);
    }
}

#define TRACE_UFS_PROCESS_DB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_PROCESS_DB) || \
    false)

static inline void _nocheck__trace_ufs_process_db(uint32_t slot)
{
    if (trace_event_get_state(TRACE_UFS_PROCESS_DB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_process_db " "UTRLDBR slot %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot);
#line 242 "trace/trace-hw_ufs.h"
        } else {
#line 6 "../hw/ufs/trace-events"
            qemu_log("ufs_process_db " "UTRLDBR slot %"PRIu32"" "\n", slot);
#line 246 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_process_db(uint32_t slot)
{
    if (true) {
        _nocheck__trace_ufs_process_db(slot);
    }
}

#define TRACE_UFS_PROCESS_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_PROCESS_REQ) || \
    false)

static inline void _nocheck__trace_ufs_process_req(uint32_t slot)
{
    if (trace_event_get_state(TRACE_UFS_PROCESS_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_process_req " "UTRLDBR slot %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot);
#line 273 "trace/trace-hw_ufs.h"
        } else {
#line 7 "../hw/ufs/trace-events"
            qemu_log("ufs_process_req " "UTRLDBR slot %"PRIu32"" "\n", slot);
#line 277 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_process_req(uint32_t slot)
{
    if (true) {
        _nocheck__trace_ufs_process_req(slot);
    }
}

#define TRACE_UFS_COMPLETE_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_COMPLETE_REQ) || \
    false)

static inline void _nocheck__trace_ufs_complete_req(uint32_t slot)
{
    if (trace_event_get_state(TRACE_UFS_COMPLETE_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_complete_req " "UTRLDBR slot %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot);
#line 304 "trace/trace-hw_ufs.h"
        } else {
#line 8 "../hw/ufs/trace-events"
            qemu_log("ufs_complete_req " "UTRLDBR slot %"PRIu32"" "\n", slot);
#line 308 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_complete_req(uint32_t slot)
{
    if (true) {
        _nocheck__trace_ufs_complete_req(slot);
    }
}

#define TRACE_UFS_SENDBACK_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_SENDBACK_REQ) || \
    false)

static inline void _nocheck__trace_ufs_sendback_req(uint32_t slot)
{
    if (trace_event_get_state(TRACE_UFS_SENDBACK_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_sendback_req " "UTRLDBR slot %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot);
#line 335 "trace/trace-hw_ufs.h"
        } else {
#line 9 "../hw/ufs/trace-events"
            qemu_log("ufs_sendback_req " "UTRLDBR slot %"PRIu32"" "\n", slot);
#line 339 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_sendback_req(uint32_t slot)
{
    if (true) {
        _nocheck__trace_ufs_sendback_req(slot);
    }
}

#define TRACE_UFS_EXEC_NOP_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_EXEC_NOP_CMD) || \
    false)

static inline void _nocheck__trace_ufs_exec_nop_cmd(uint32_t slot)
{
    if (trace_event_get_state(TRACE_UFS_EXEC_NOP_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_exec_nop_cmd " "UTRLDBR slot %"PRIu32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot);
#line 366 "trace/trace-hw_ufs.h"
        } else {
#line 10 "../hw/ufs/trace-events"
            qemu_log("ufs_exec_nop_cmd " "UTRLDBR slot %"PRIu32"" "\n", slot);
#line 370 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_exec_nop_cmd(uint32_t slot)
{
    if (true) {
        _nocheck__trace_ufs_exec_nop_cmd(slot);
    }
}

#define TRACE_UFS_EXEC_SCSI_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_EXEC_SCSI_CMD) || \
    false)

static inline void _nocheck__trace_ufs_exec_scsi_cmd(uint32_t slot, uint8_t lun, uint8_t opcode)
{
    if (trace_event_get_state(TRACE_UFS_EXEC_SCSI_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_exec_scsi_cmd " "slot %"PRIu32", lun 0x%"PRIx8", opcode 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, lun, opcode);
#line 397 "trace/trace-hw_ufs.h"
        } else {
#line 11 "../hw/ufs/trace-events"
            qemu_log("ufs_exec_scsi_cmd " "slot %"PRIu32", lun 0x%"PRIx8", opcode 0x%"PRIx8"" "\n", slot, lun, opcode);
#line 401 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_exec_scsi_cmd(uint32_t slot, uint8_t lun, uint8_t opcode)
{
    if (true) {
        _nocheck__trace_ufs_exec_scsi_cmd(slot, lun, opcode);
    }
}

#define TRACE_UFS_EXEC_QUERY_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_EXEC_QUERY_CMD) || \
    false)

static inline void _nocheck__trace_ufs_exec_query_cmd(uint32_t slot, uint8_t opcode)
{
    if (trace_event_get_state(TRACE_UFS_EXEC_QUERY_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_exec_query_cmd " "slot %"PRIu32", opcode 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, opcode);
#line 428 "trace/trace-hw_ufs.h"
        } else {
#line 12 "../hw/ufs/trace-events"
            qemu_log("ufs_exec_query_cmd " "slot %"PRIu32", opcode 0x%"PRIx8"" "\n", slot, opcode);
#line 432 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_exec_query_cmd(uint32_t slot, uint8_t opcode)
{
    if (true) {
        _nocheck__trace_ufs_exec_query_cmd(slot, opcode);
    }
}

#define TRACE_UFS_PROCESS_UICCMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_PROCESS_UICCMD) || \
    false)

static inline void _nocheck__trace_ufs_process_uiccmd(uint32_t uiccmd, uint32_t ucmdarg1, uint32_t ucmdarg2, uint32_t ucmdarg3)
{
    if (trace_event_get_state(TRACE_UFS_PROCESS_UICCMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_process_uiccmd " "uiccmd 0x%"PRIx32", ucmdarg1 0x%"PRIx32", ucmdarg2 0x%"PRIx32", ucmdarg3 0x%"PRIx32"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , uiccmd, ucmdarg1, ucmdarg2, ucmdarg3);
#line 459 "trace/trace-hw_ufs.h"
        } else {
#line 13 "../hw/ufs/trace-events"
            qemu_log("ufs_process_uiccmd " "uiccmd 0x%"PRIx32", ucmdarg1 0x%"PRIx32", ucmdarg2 0x%"PRIx32", ucmdarg3 0x%"PRIx32"" "\n", uiccmd, ucmdarg1, ucmdarg2, ucmdarg3);
#line 463 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_process_uiccmd(uint32_t uiccmd, uint32_t ucmdarg1, uint32_t ucmdarg2, uint32_t ucmdarg3)
{
    if (true) {
        _nocheck__trace_ufs_process_uiccmd(uiccmd, ucmdarg1, ucmdarg2, ucmdarg3);
    }
}

#define TRACE_UFS_ERR_DMA_READ_UTRD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_DMA_READ_UTRD) || \
    false)

static inline void _nocheck__trace_ufs_err_dma_read_utrd(uint32_t slot, uint64_t addr)
{
    if (trace_event_get_state(TRACE_UFS_ERR_DMA_READ_UTRD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_dma_read_utrd " "failed to read utrd. UTRLDBR slot %"PRIu32", UTRD dma addr %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, addr);
#line 490 "trace/trace-hw_ufs.h"
        } else {
#line 16 "../hw/ufs/trace-events"
            qemu_log("ufs_err_dma_read_utrd " "failed to read utrd. UTRLDBR slot %"PRIu32", UTRD dma addr %"PRIu64"" "\n", slot, addr);
#line 494 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_dma_read_utrd(uint32_t slot, uint64_t addr)
{
    if (true) {
        _nocheck__trace_ufs_err_dma_read_utrd(slot, addr);
    }
}

#define TRACE_UFS_ERR_DMA_READ_REQ_UPIU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_DMA_READ_REQ_UPIU) || \
    false)

static inline void _nocheck__trace_ufs_err_dma_read_req_upiu(uint32_t slot, uint64_t addr)
{
    if (trace_event_get_state(TRACE_UFS_ERR_DMA_READ_REQ_UPIU) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_dma_read_req_upiu " "failed to read req upiu. UTRLDBR slot %"PRIu32", request upiu addr %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, addr);
#line 521 "trace/trace-hw_ufs.h"
        } else {
#line 17 "../hw/ufs/trace-events"
            qemu_log("ufs_err_dma_read_req_upiu " "failed to read req upiu. UTRLDBR slot %"PRIu32", request upiu addr %"PRIu64"" "\n", slot, addr);
#line 525 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_dma_read_req_upiu(uint32_t slot, uint64_t addr)
{
    if (true) {
        _nocheck__trace_ufs_err_dma_read_req_upiu(slot, addr);
    }
}

#define TRACE_UFS_ERR_DMA_READ_PRDT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_DMA_READ_PRDT) || \
    false)

static inline void _nocheck__trace_ufs_err_dma_read_prdt(uint32_t slot, uint64_t addr)
{
    if (trace_event_get_state(TRACE_UFS_ERR_DMA_READ_PRDT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_dma_read_prdt " "failed to read prdt. UTRLDBR slot %"PRIu32", prdt addr %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, addr);
#line 552 "trace/trace-hw_ufs.h"
        } else {
#line 18 "../hw/ufs/trace-events"
            qemu_log("ufs_err_dma_read_prdt " "failed to read prdt. UTRLDBR slot %"PRIu32", prdt addr %"PRIu64"" "\n", slot, addr);
#line 556 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_dma_read_prdt(uint32_t slot, uint64_t addr)
{
    if (true) {
        _nocheck__trace_ufs_err_dma_read_prdt(slot, addr);
    }
}

#define TRACE_UFS_ERR_DMA_WRITE_UTRD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_DMA_WRITE_UTRD) || \
    false)

static inline void _nocheck__trace_ufs_err_dma_write_utrd(uint32_t slot, uint64_t addr)
{
    if (trace_event_get_state(TRACE_UFS_ERR_DMA_WRITE_UTRD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_dma_write_utrd " "failed to write utrd. UTRLDBR slot %"PRIu32", UTRD dma addr %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, addr);
#line 583 "trace/trace-hw_ufs.h"
        } else {
#line 19 "../hw/ufs/trace-events"
            qemu_log("ufs_err_dma_write_utrd " "failed to write utrd. UTRLDBR slot %"PRIu32", UTRD dma addr %"PRIu64"" "\n", slot, addr);
#line 587 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_dma_write_utrd(uint32_t slot, uint64_t addr)
{
    if (true) {
        _nocheck__trace_ufs_err_dma_write_utrd(slot, addr);
    }
}

#define TRACE_UFS_ERR_DMA_WRITE_RSP_UPIU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_DMA_WRITE_RSP_UPIU) || \
    false)

static inline void _nocheck__trace_ufs_err_dma_write_rsp_upiu(uint32_t slot, uint64_t addr)
{
    if (trace_event_get_state(TRACE_UFS_ERR_DMA_WRITE_RSP_UPIU) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_dma_write_rsp_upiu " "failed to write rsp upiu. UTRLDBR slot %"PRIu32", response upiu addr %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, addr);
#line 614 "trace/trace-hw_ufs.h"
        } else {
#line 20 "../hw/ufs/trace-events"
            qemu_log("ufs_err_dma_write_rsp_upiu " "failed to write rsp upiu. UTRLDBR slot %"PRIu32", response upiu addr %"PRIu64"" "\n", slot, addr);
#line 618 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_dma_write_rsp_upiu(uint32_t slot, uint64_t addr)
{
    if (true) {
        _nocheck__trace_ufs_err_dma_write_rsp_upiu(slot, addr);
    }
}

#define TRACE_UFS_ERR_UTRL_SLOT_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_UTRL_SLOT_ERROR) || \
    false)

static inline void _nocheck__trace_ufs_err_utrl_slot_error(uint32_t slot)
{
    if (trace_event_get_state(TRACE_UFS_ERR_UTRL_SLOT_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_utrl_slot_error " "UTRLDBR slot %"PRIu32" is in error" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot);
#line 645 "trace/trace-hw_ufs.h"
        } else {
#line 21 "../hw/ufs/trace-events"
            qemu_log("ufs_err_utrl_slot_error " "UTRLDBR slot %"PRIu32" is in error" "\n", slot);
#line 649 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_utrl_slot_error(uint32_t slot)
{
    if (true) {
        _nocheck__trace_ufs_err_utrl_slot_error(slot);
    }
}

#define TRACE_UFS_ERR_UTRL_SLOT_BUSY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_UTRL_SLOT_BUSY) || \
    false)

static inline void _nocheck__trace_ufs_err_utrl_slot_busy(uint32_t slot)
{
    if (trace_event_get_state(TRACE_UFS_ERR_UTRL_SLOT_BUSY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_utrl_slot_busy " "UTRLDBR slot %"PRIu32" is busy" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot);
#line 676 "trace/trace-hw_ufs.h"
        } else {
#line 22 "../hw/ufs/trace-events"
            qemu_log("ufs_err_utrl_slot_busy " "UTRLDBR slot %"PRIu32" is busy" "\n", slot);
#line 680 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_utrl_slot_busy(uint32_t slot)
{
    if (true) {
        _nocheck__trace_ufs_err_utrl_slot_busy(slot);
    }
}

#define TRACE_UFS_ERR_UNSUPPORT_REGISTER_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_UNSUPPORT_REGISTER_OFFSET) || \
    false)

static inline void _nocheck__trace_ufs_err_unsupport_register_offset(uint32_t offset)
{
    if (trace_event_get_state(TRACE_UFS_ERR_UNSUPPORT_REGISTER_OFFSET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_unsupport_register_offset " "Register offset 0x%"PRIx32" is not yet supported" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 707 "trace/trace-hw_ufs.h"
        } else {
#line 23 "../hw/ufs/trace-events"
            qemu_log("ufs_err_unsupport_register_offset " "Register offset 0x%"PRIx32" is not yet supported" "\n", offset);
#line 711 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_unsupport_register_offset(uint32_t offset)
{
    if (true) {
        _nocheck__trace_ufs_err_unsupport_register_offset(offset);
    }
}

#define TRACE_UFS_ERR_INVALID_REGISTER_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_INVALID_REGISTER_OFFSET) || \
    false)

static inline void _nocheck__trace_ufs_err_invalid_register_offset(uint32_t offset)
{
    if (trace_event_get_state(TRACE_UFS_ERR_INVALID_REGISTER_OFFSET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_invalid_register_offset " "Register offset 0x%"PRIx32" is invalid" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset);
#line 738 "trace/trace-hw_ufs.h"
        } else {
#line 24 "../hw/ufs/trace-events"
            qemu_log("ufs_err_invalid_register_offset " "Register offset 0x%"PRIx32" is invalid" "\n", offset);
#line 742 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_invalid_register_offset(uint32_t offset)
{
    if (true) {
        _nocheck__trace_ufs_err_invalid_register_offset(offset);
    }
}

#define TRACE_UFS_ERR_SCSI_CMD_INVALID_LUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_SCSI_CMD_INVALID_LUN) || \
    false)

static inline void _nocheck__trace_ufs_err_scsi_cmd_invalid_lun(uint8_t lun)
{
    if (trace_event_get_state(TRACE_UFS_ERR_SCSI_CMD_INVALID_LUN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_scsi_cmd_invalid_lun " "scsi command has invalid lun: 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lun);
#line 769 "trace/trace-hw_ufs.h"
        } else {
#line 25 "../hw/ufs/trace-events"
            qemu_log("ufs_err_scsi_cmd_invalid_lun " "scsi command has invalid lun: 0x%"PRIx8"" "\n", lun);
#line 773 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_scsi_cmd_invalid_lun(uint8_t lun)
{
    if (true) {
        _nocheck__trace_ufs_err_scsi_cmd_invalid_lun(lun);
    }
}

#define TRACE_UFS_ERR_QUERY_FLAG_NOT_READABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_QUERY_FLAG_NOT_READABLE) || \
    false)

static inline void _nocheck__trace_ufs_err_query_flag_not_readable(uint8_t idn)
{
    if (trace_event_get_state(TRACE_UFS_ERR_QUERY_FLAG_NOT_READABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_query_flag_not_readable " "query flag idn 0x%"PRIx8" is denied to read" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idn);
#line 800 "trace/trace-hw_ufs.h"
        } else {
#line 26 "../hw/ufs/trace-events"
            qemu_log("ufs_err_query_flag_not_readable " "query flag idn 0x%"PRIx8" is denied to read" "\n", idn);
#line 804 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_query_flag_not_readable(uint8_t idn)
{
    if (true) {
        _nocheck__trace_ufs_err_query_flag_not_readable(idn);
    }
}

#define TRACE_UFS_ERR_QUERY_FLAG_NOT_WRITABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_QUERY_FLAG_NOT_WRITABLE) || \
    false)

static inline void _nocheck__trace_ufs_err_query_flag_not_writable(uint8_t idn)
{
    if (trace_event_get_state(TRACE_UFS_ERR_QUERY_FLAG_NOT_WRITABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_query_flag_not_writable " "query flag idn 0x%"PRIx8" is denied to write" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idn);
#line 831 "trace/trace-hw_ufs.h"
        } else {
#line 27 "../hw/ufs/trace-events"
            qemu_log("ufs_err_query_flag_not_writable " "query flag idn 0x%"PRIx8" is denied to write" "\n", idn);
#line 835 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_query_flag_not_writable(uint8_t idn)
{
    if (true) {
        _nocheck__trace_ufs_err_query_flag_not_writable(idn);
    }
}

#define TRACE_UFS_ERR_QUERY_ATTR_NOT_READABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_QUERY_ATTR_NOT_READABLE) || \
    false)

static inline void _nocheck__trace_ufs_err_query_attr_not_readable(uint8_t idn)
{
    if (trace_event_get_state(TRACE_UFS_ERR_QUERY_ATTR_NOT_READABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_query_attr_not_readable " "query attribute idn 0x%"PRIx8" is denied to read" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idn);
#line 862 "trace/trace-hw_ufs.h"
        } else {
#line 28 "../hw/ufs/trace-events"
            qemu_log("ufs_err_query_attr_not_readable " "query attribute idn 0x%"PRIx8" is denied to read" "\n", idn);
#line 866 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_query_attr_not_readable(uint8_t idn)
{
    if (true) {
        _nocheck__trace_ufs_err_query_attr_not_readable(idn);
    }
}

#define TRACE_UFS_ERR_QUERY_ATTR_NOT_WRITABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_QUERY_ATTR_NOT_WRITABLE) || \
    false)

static inline void _nocheck__trace_ufs_err_query_attr_not_writable(uint8_t idn)
{
    if (trace_event_get_state(TRACE_UFS_ERR_QUERY_ATTR_NOT_WRITABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_query_attr_not_writable " "query attribute idn 0x%"PRIx8" is denied to write" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , idn);
#line 893 "trace/trace-hw_ufs.h"
        } else {
#line 29 "../hw/ufs/trace-events"
            qemu_log("ufs_err_query_attr_not_writable " "query attribute idn 0x%"PRIx8" is denied to write" "\n", idn);
#line 897 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_query_attr_not_writable(uint8_t idn)
{
    if (true) {
        _nocheck__trace_ufs_err_query_attr_not_writable(idn);
    }
}

#define TRACE_UFS_ERR_QUERY_INVALID_OPCODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_QUERY_INVALID_OPCODE) || \
    false)

static inline void _nocheck__trace_ufs_err_query_invalid_opcode(uint8_t opcode)
{
    if (trace_event_get_state(TRACE_UFS_ERR_QUERY_INVALID_OPCODE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_query_invalid_opcode " "query request has invalid opcode. opcode: 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , opcode);
#line 924 "trace/trace-hw_ufs.h"
        } else {
#line 30 "../hw/ufs/trace-events"
            qemu_log("ufs_err_query_invalid_opcode " "query request has invalid opcode. opcode: 0x%"PRIx8"" "\n", opcode);
#line 928 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_query_invalid_opcode(uint8_t opcode)
{
    if (true) {
        _nocheck__trace_ufs_err_query_invalid_opcode(opcode);
    }
}

#define TRACE_UFS_ERR_QUERY_INVALID_IDN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_QUERY_INVALID_IDN) || \
    false)

static inline void _nocheck__trace_ufs_err_query_invalid_idn(uint8_t opcode, uint8_t idn)
{
    if (trace_event_get_state(TRACE_UFS_ERR_QUERY_INVALID_IDN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_query_invalid_idn " "query request has invalid idn. opcode: 0x%"PRIx8", idn 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , opcode, idn);
#line 955 "trace/trace-hw_ufs.h"
        } else {
#line 31 "../hw/ufs/trace-events"
            qemu_log("ufs_err_query_invalid_idn " "query request has invalid idn. opcode: 0x%"PRIx8", idn 0x%"PRIx8"" "\n", opcode, idn);
#line 959 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_query_invalid_idn(uint8_t opcode, uint8_t idn)
{
    if (true) {
        _nocheck__trace_ufs_err_query_invalid_idn(opcode, idn);
    }
}

#define TRACE_UFS_ERR_QUERY_INVALID_INDEX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_QUERY_INVALID_INDEX) || \
    false)

static inline void _nocheck__trace_ufs_err_query_invalid_index(uint8_t opcode, uint8_t index)
{
    if (trace_event_get_state(TRACE_UFS_ERR_QUERY_INVALID_INDEX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_query_invalid_index " "query request has invalid index. opcode: 0x%"PRIx8", index 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , opcode, index);
#line 986 "trace/trace-hw_ufs.h"
        } else {
#line 32 "../hw/ufs/trace-events"
            qemu_log("ufs_err_query_invalid_index " "query request has invalid index. opcode: 0x%"PRIx8", index 0x%"PRIx8"" "\n", opcode, index);
#line 990 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_query_invalid_index(uint8_t opcode, uint8_t index)
{
    if (true) {
        _nocheck__trace_ufs_err_query_invalid_index(opcode, index);
    }
}

#define TRACE_UFS_ERR_INVALID_TRANS_CODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_UFS_ERR_INVALID_TRANS_CODE) || \
    false)

static inline void _nocheck__trace_ufs_err_invalid_trans_code(uint32_t slot, uint8_t trans_code)
{
    if (trace_event_get_state(TRACE_UFS_ERR_INVALID_TRANS_CODE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "../hw/ufs/trace-events"
            qemu_log("%d@%zu.%06zu:ufs_err_invalid_trans_code " "request upiu has invalid transaction code. slot: %"PRIu32", trans_code: 0x%"PRIx8"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , slot, trans_code);
#line 1017 "trace/trace-hw_ufs.h"
        } else {
#line 33 "../hw/ufs/trace-events"
            qemu_log("ufs_err_invalid_trans_code " "request upiu has invalid transaction code. slot: %"PRIu32", trans_code: 0x%"PRIx8"" "\n", slot, trans_code);
#line 1021 "trace/trace-hw_ufs.h"
        }
    }
}

static inline void trace_ufs_err_invalid_trans_code(uint32_t slot, uint8_t trans_code)
{
    if (true) {
        _nocheck__trace_ufs_err_invalid_trans_code(slot, trans_code);
    }
}
#endif /* TRACE_HW_UFS_GENERATED_TRACERS_H */
